<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lavalamp.app</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body style="font-family: Arial">
<script src="https://cdn.jsdelivr.net/npm/nosleep.js@0.11.0/dist/NoSleep.min.js"></script>
<script type="module">
  import {
    button,
    div,
    img,
    input,
    label,
    hr,
    a,
    sub
  } from 'https://cdn.jsdelivr.net/npm/@srfnstack/fntags@0.3.8/src/fnelements.min.mjs'
  import { fnstate } from 'https://cdn.jsdelivr.net/npm/@srfnstack/fntags@0.3.8/src/fntags.min.mjs'

  const noSleep = new NoSleep()

  const clamp = (value, min, max) => Math.min(Math.max(value, min), max)

  // borrowed from https://gist.github.com/peeke/e65e8c162a22b21ac9ac9de07a4afeac
  class SpatialHashMap {
    constructor (width, height) {
      this.width = width
      this.height = height
      this.grid = new Array(width * height).fill(null).map(() => [])
    }

    clear () {
      this.grid.forEach(cell => {
        cell.splice(0)
      })
    }

    add (x, y, data) {
      x = clamp(Math.round(x), 0, this.width - 1)
      y = clamp(Math.round(y), 0, this.height - 1)

      const index = x + y * this.width
      let cell = this.grid[index]
      cell.push(data)
    }

    query (x, y, radius) {
      if (radius) {
        return this.queryWithRadius(x, y, radius)
      }

      x = clamp(Math.round(x), 0, this.width - 1)
      y = clamp(Math.round(y), 0, this.height - 1)

      const index = x + y * this.width
      return this.grid[index]
    }

    queryWithRadius (x, y, radius) {
      const left = Math.max(Math.round(x - radius), 0)
      const right = Math.min(Math.round(x + radius), this.width - 1)
      const bottom = Math.max(Math.round(y - radius), 0)
      const top = Math.min(Math.round(y + radius), this.height - 1)

      const result = []

      for (let i = left; i <= right; i++) {
        for (let j = bottom; j <= top; j++) {
          const query = this.query(i, j)
          for (let k = 0; k < query.length; k++) {
            result.push(query[k])
          }
        }
      }

      return result
    }
  }

  function enableNoSleep () {
    document.removeEventListener('click', enableNoSleep, false)
    noSleep.enable()
    notify('Wake Lock Activated')
  }

  function notify (...message) {
    let notification = div(
      {
        style: {
          position: 'fixed',
          bottom: '20px',
          left: '20px',
          width: '25vw',
          'min-width': '250px',
          background: 'rgb(220,220,220,.6)',
          'text-align': 'center',
          'line-height': '100px',
          'font-size': '25px',
          'z-index': 100,
          'border-radius': '8px'
        }
      },
      ...message
    )
    document.body.append(notification)
    let notifyTime = 2000
    notification.animate(
      [
        { opacity: 1 },
        { opacity: 0 }
      ],
      notifyTime
    )
    notification.style.opacity = 0
    setTimeout(() => notification.remove(), notifyTime)
  }

  document.addEventListener('click', enableNoSleep, false)

  const defaultBgHsl = { h: 20, s: 20, l: 20 }
  const defaultLavaHsl = { h: 285, s: 100, l: 65 }
  const defaultParticleCount = 400
  const defaultLavaFuzziness = 8
  const defaultInteractionRadius = 35
  const defaultStiffness = 5000
  const defaultStiffnessNear = 30000
  const defaultRestDensity = 5.45
  const defaultLavaSize = 17
  const defaultLampTemp = 200
  const defaultAmbientTemp = 200
  const defaultMaxHeat = () => 1281
  const defaultGravityStrength = 600

  const size = Math.min(Math.max(window.innerWidth, window.innerHeight), 600)
  const GRID_CELLS = 54
  const interactionRadius = fnstate(defaultInteractionRadius)
  const gravityStrength = fnstate(defaultGravityStrength)
  const stiffness = fnstate(defaultStiffness)
  const stiffnessNear = fnstate(defaultStiffnessNear)
  const restDensity = fnstate(defaultRestDensity)
  const maxTemp = fnstate(defaultMaxHeat())
  const lampTemp = fnstate(defaultLampTemp)
  const ambientTemp = fnstate(defaultAmbientTemp)
  const gravity = [0, gravityStrength()]
  const DEVICE_FORCE = [0, 0]
  const deviceAcceleration = [0, 0]
  let interactionRadiusSq = interactionRadius() * interactionRadius()
  interactionRadius.subscribe(() => {
    interactionRadiusSq = interactionRadius() * interactionRadius()
  })

  const bgHsl = fnstate(Object.assign({}, defaultBgHsl))
  const lavaHsl = fnstate(Object.assign({}, defaultLavaHsl))
  const particleCount = fnstate(defaultParticleCount)
  const lavaFuzziness = fnstate(defaultLavaFuzziness)
  const lavaSize = fnstate(defaultLavaSize)

  const applySettings = obj => {
    bgHsl(obj.bgHsl || Object.assign({}, defaultBgHsl))
    lavaHsl(obj.lavaHsl || Object.assign({}, lavaHsl(obj.lavaHsl || Object.assign({}, defaultBgHsl))))
    particleCount(obj.amountOfLava || particleCount())
    lavaFuzziness(obj.lavaFuzziness || lavaFuzziness())
    lavaSize(obj.lavaSizeFactor || lavaSize())
  }

  const getSettings = () => ( {
    bgHsl: bgHsl(),
    lavaHsl: lavaHsl(),
    amountOfLava: particleCount(),
    lavaFuzziness: lavaFuzziness(),
    lavaSizeFactor: lavaSize(),
    particleCount: particleCount(),
    interactionRadius: interactionRadius(),
    stiffness: stiffness(),
    stiffnessNear: stiffnessNear(),
    restDensity: restDensity(),
    maxHeat: maxTemp()
  } )

  let settingsKey = 'lavalamp.app-settings'
  if (localStorage.getItem(settingsKey)) {
    applySettings(JSON.parse(localStorage.getItem(settingsKey)))
  }

  const urlParams = new URLSearchParams(window.location.search)
  if (urlParams.get('shared')) {
    try {
      applySettings(JSON.parse(atob(urlParams.get('shared'))))
    } catch {
      notify('Invalid Share URL')
    }
  }

  const saveSettings = () => {
    localStorage.setItem(
      settingsKey,
      JSON.stringify(getSettings)
    )
    settings.remove()
  }

  const resetDefaults = () => {
    if (confirm('This will reset ALL defaults')) {
      localStorage.removeItem(settingsKey)
      bgHsl(Object.assign({}, defaultBgHsl))
      lavaHsl(Object.assign({}, defaultLavaHsl))
      lavaFuzziness(defaultLavaFuzziness)
      lavaSize(defaultLavaSize)
      particleCount(defaultParticleCount)
      gravityStrength(defaultGravityStrength)
    }

  }

  const randomBetween = (min, max) => Math.trunc(Math.random() * ( max - min ) + min)

  function randomNormalDistribution (min, max, skew = 1) {
    let u = 0, v = 0
    while (u === 0) {
      u = Math.random()
    } //Converting [0,1) to (0,1)
    while (v === 0) {
      v = Math.random()
    }
    let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)

    num = num / 10.0 + 0.5 // Translate to 0 -> 1
    if (num > 1 || num < 0) num = randomNormalDistribution(min, max, skew) // resample between 0 and 1 if out of range
    num = Math.pow(num, skew) // Skew
    num *= max - min // Stretch to fill range
    num += min // offset to min
    return Math.trunc(num)
  }

  const formInput = (inputLabel, theInput, setDefault) => {
    theInput.style.cursor = 'pointer'
    return div(
      {
        style: {
          display: 'flex',
          'flex-direction': 'row',
          'width': '100%',
          margin: '10px',
          'justify-content': 'space-between'
        }
      },
      label({ for: theInput.getAttribute('id') }, inputLabel),
      div(
        {
          style: {
            display: 'flex',
            'flex-direction': 'row'
          }
        },
        theInput,
        setDefault ? setDefault : ''
      )
    )
  }
  let id = 0
  const resetToDefaultButton = (clickHandler, style) => div(
    {
      onclick: clickHandler,
      tooltip: 'Reset To Default',
      style: Object.assign({
        cursor: 'pointer',
        'margin-right': '-10px',
        'margin-left': '20px'
      }, style)
    },
    'x'
  )
  //
  // const hslRange = (name, attr, state, defaultHsl, min, max) => div(
  //   {
  //     style: {
  //       display: 'flex',
  //       'flex-direction': 'column',
  //       'margin-top': '5px'
  //     }
  //   },
  //   name,
  //   div(
  //     {
  //       style: {
  //         display: 'flex',
  //         'flex-direction': 'row'
  //       }
  //     },
  //     input({
  //       id: id++,
  //       type: 'range',
  //       value: state.bindAttr(() => state()[attr]),
  //       min: min,
  //       max: max,
  //       step: 1,
  //       oninput: (e) => state.patch({ [attr]: parseInt(e.target.value) })
  //     }),
  //     resetToDefaultButton(() => state.patch({ [attr]: defaultHsl[attr] }), {
  //       'margin-right': '10px',
  //       'margin-left': '20px'
  //     })
  //   )
  // )
  //
  // const hslInput = (name, state, defaultHsl) => div(
  //   {
  //     style: {
  //       'text-align': 'center',
  //       'margin-top': '5px'
  //     }
  //   },
  //   name,
  //   hr({ width: '30%' }),
  //   div(
  //     {
  //       style: {
  //         display: 'flex',
  //         'flex-direction': 'row',
  //         'flex-wrap': 'wrap',
  //         'align-items': 'center',
  //         'justify-content': 'center'
  //       }
  //     },
  //     hslRange('Hue', 'h', state, defaultHsl, 1, 358),
  //     hslRange('Saturation', 's', state, defaultHsl, 1, 100),
  //     hslRange('Brightness', 'l', state, defaultHsl, 20, 70)
  //   )
  // )

  const copyShareLink = () =>
    navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}?shared=${btoa(JSON.stringify(getSettings()))}`)
      .then(function () {
        notify('Link Copied to Clipboard')
      }, function (err) {
        notify('Failed to Copy Share Link...')
        console.error(err)
      })

  const settings = div({
      style: {
        float: 'left',
        background: 'rgb(150,150,150,.6)',
        'z-index': 20,
        padding: '22px 22px',
        display: 'flex',
        position: 'relative',
        'max-width': '700px',
        'border-radius': '10px',
        'flex-direction': 'column',
        'justify-content': 'space-evenly',
        'align-items': 'center'
      }
    },
    // hslInput('Background', bgHsl, defaultBgHsl),
    // hslInput('Lava', lavaHsl, defaultLavaHsl),
    formInput(
      'Lava Fuzziness',
      input({
        id: 'lavaFuzziness',
        type: 'range',
        min: 2,
        step: 1,
        max: 50,
        value: lavaFuzziness.bindAttr(lavaFuzziness),
        oninput: (e) => lavaFuzziness(e.target.value)
      }),
      resetToDefaultButton(() => lavaFuzziness(defaultLavaFuzziness))
    ),
    formInput(
      'Lava Size',
      input({
        id: 'lavaSize',
        type: 'range',
        min: 2,
        step: 1,
        max: 50,
        value: lavaSize.bindAttr(lavaSize),
        oninput: (e) => lavaSize(e.target.value)
      }),
      resetToDefaultButton(() => lavaSize(defaultLavaSize))
    ),
    // formInput(
    //   'Share',
    //   button({
    //     id: 'share', onclick: copyShareLink,
    //     style: {
    //       'border-radius': '5px',
    //       padding: '5px'
    //     }
    //   }, 'Share')
    // ),
    // formInput(
    //   'Save',
    //   button({
    //     id: 'save', onclick: saveSettings,
    //     style: {
    //       'border-radius': '5px',
    //       padding: '5px'
    //     }
    //   }, 'Save and Close')
    // ),
    formInput(
      'Amount of Lava',
      input({
        id: 'lava-amount',
        type: 'range',
        value: particleCount.bindAttr(),
        step: 1,
        min: 5,
        max: Math.trunc(defaultParticleCount * 2),
        oninput: (e) => particleCount(parseInt(e.target.value))
      }),
      resetToDefaultButton(() => particleCount(defaultParticleCount))
    ),
    formInput(
      'Interaction Radius',
      input({
        id: 'interaction-radius',
        type: 'range',
        value: interactionRadius.bindAttr(),
        step: 1,
        min: 1,
        max: 200,
        oninput: (e) => interactionRadius(e.target.value)
      }),
      resetToDefaultButton(() => interactionRadius(defaultInteractionRadius))
    ),
    formInput(
      'Stiffness',
      input({
        id: 'stiffness',
        type: 'range',
        value: stiffness.bindAttr(),
        step: 1,
        min: 1,
        max: 20000,
        oninput: (e) => stiffness(e.target.value)
      }),
      resetToDefaultButton(() => stiffness(defaultStiffness))
    ),
    formInput(
      'Stiffness Near',
      input({
        id: 'stiffness-near',
        type: 'range',
        value: stiffnessNear.bindAttr(),
        step: 10,
        min: 1,
        max: 100000,
        oninput: (e) => stiffnessNear(e.target.value)
      }),
      resetToDefaultButton(() => stiffnessNear(defaultStiffnessNear))
    ),
    formInput(
      'Rest Density',
      input({
        id: 'rest-density',
        type: 'range',
        value: restDensity.bindAttr(),
        step: .01,
        min: .01,
        max: 50,
        oninput: (e) => restDensity(e.target.value)
      }),
      resetToDefaultButton(() => restDensity(defaultRestDensity))
    ),
    formInput(
      'Max Temp',
      input({
        id: 'max-temp',
        type: 'range',
        value: maxTemp.bindAttr(),
        step: 1,
        min: 1,
        max: 2000,
        oninput: (e) => maxTemp(e.target.value)
      }),
      resetToDefaultButton(() => maxTemp(defaultMaxHeat()))
    ),
    formInput(
      'Lamp Temperature',
      input({
        id: 'lamp-temp',
        type: 'range',
        value: lampTemp.bindAttr(),
        step: 1,
        min: 1,
        max: 100,
        oninput: (e) => lampTemp(e.target.value)
      }),
      resetToDefaultButton(() => lampTemp(defaultLampTemp))
    ),
    formInput(
      'Ambient Temperature',
      input({
        id: 'ambient-temp',
        type: 'range',
        value: ambientTemp.bindAttr(),
        step: 1,
        min: 1,
        max: 500,
        oninput: (e) => ambientTemp(e.target.value)
      }),
      resetToDefaultButton(() => ambientTemp(defaultAmbientTemp))
    ),
    formInput(
      'Gravity Strength',
      input({
        id: 'gravity',
        type: 'range',
        value: gravityStrength.bindAttr(),
        step: 1,
        min: 0,
        max: 1000,
        oninput: (e) => gravityStrength(parseFloat(e.target.value))
      }),
      resetToDefaultButton(() => gravityStrength(defaultGravityStrength))
    ),
    formInput('Print Settings', button({
      id: 'print', onclick: () => {
        console.log(JSON.stringify(getSettings(), null, ' '))
      },
      style: {
        'border-radius': '5px',
        padding: '5px'
      }
    }, 'Log Settings')),
    // formInput('Reset Defaults', button({
    //   id: 'reset', onclick: resetDefaults,
    //   style: {
    //     'border-radius': '5px',
    //     padding: '5px'
    //   }
    // }, 'Reset Defaults')),
    div({
        style: {
          position: 'absolute',
          top: '10px',
          right: '20px',
          'font-style': 'sans-serif',
          'font-size': '26px',
          cursor: 'pointer'
        },
        onclick: () => settings.remove()
      },
      'x'
    )
  )

  let lavalamp = () => div(
    {
      id: 'lavalamp',
      style: {
        // filter: 'url("#lava")',
        filter: `blur(${lavaFuzziness()}px)`

      }
    })
  const bg = (lamp) => div({
      style: {
        position: 'fixed',
        filter: 'brightness(.9) contrast(10)',
        'z-index': -100,
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        background: `hsl(${bgHsl().h}, ${bgHsl().s}%, ${bgHsl().l}%)`
      }
    },
    lamp,
    div(
      {
        style: {
          position: 'fixed',
          top: '10px',
          left: '20px',
          cursor: 'pointer',
          'z-index': 10
        }
      },
      img({
        src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAHwnpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjarZhZkiOxDUT/eQofobiAy3G4RvgGPr4fyJLUUve0xw5Loy4ViguATCShMfNf/1zmH7xcKJcJknIsMV68QgnFVb7k67zO1V5h/90vdz/i/s1ung8cJs/Vn9s47/EVu7wmpHDb27vdpH6vk++F7PW2tded9fu4nbwX8u7Y7X1vyj2hxi/h3B/X72UfYX3ch0QyhrCed8ZNb/11/p6d/PlULHb/FQZe2xJ4V57a7/kzz9T9kMDnt4/8XQ/P/CsdZ6FHWPEjT7fdyofdP7dxbx5Z99zZffWouicRvuVvrZHXmie6GqIhXfEO6hHK/sbARjr9nhZ5Jz7C97TfhXe+6tVBbRBqM1fjplhHrpcNdthql5372m3HxeCmS1yd62RZbdknV1wn/XanP9jlkvHFD59BooOcx+yevti9b9H92Cyz87CMdJbFLDPe3ubT8L++3xZaS2lu7ZWfucIvp5TFDUVO/zIKQOy6cyo7v9acy/X5UmA9CMpOcybAerWzRBP74pbfOPtLDEPDderFpnEvQIrYW3AGdgd7Rehto72Sc8la8pjBp+K588E1ELBixA28dMH7CDjZ6d7MSXaPdeKOGXkBCPHRJ6ApvgJWCBIi9ZahUDXiJYhIlCRZitToY4gSY0xRdaomn0KSFFNKOZVUs88hS4455ZxLrsUVj4yJKbGkkksptbJpDZW1KuMrhuaab6FJiy213EqrHfr00KXHnnrupdfhhh9IgBlxpJFHGXXaCZVmmDLjTDPPMuuCa8uvsGTFlVZeZdUnajeq76h9Ivc7avZGzW2gdFx6oYY5pccSVuVEFDMQc8GCeFIEILRTzK5sQ3CKnGJ2FeeNR7fwUhScYRUxEAzTOln2id0LuT/iZsjuf4ub+wk5o9D9P5AzCt0X5L7j9gNqo2659RsgrUJyikJ6yo9B1WX+qSz+5XUVyoOdKuvPbFh3NnWv1+7ZyTXCm4lAGO0JbtVZ2/S1rmbjnxc213/jCU6wlp+sjTMYZnP7vlXzzeEcZ2uXZoshwvgRMM7YZo/b4+nUO8HgS9VccVeiadPqwlUXbuW7G20GMJDtCOFzL45w22eU5pv3eeqimkO/FP9FpxCBNqgbuu7EDb258MmypA+XHcVIKkv8GZ98k5oERqSRCs+XH3y9ShDtFST15WUhS1afXXNE4fEcspwzNBnJNRnM8FbKnp7sSD1B9BU622diGbFLYqI+tnWkyrJMCzvXg1jMThnI1h+pkiPQT+FLmdvQ3CTbsU69J6sP+nkz6S8yo7vd9zNqKqmyvyVlIW3UjTM6WbNK5lr7OgoR3zwcUnvSALmd6uRQJlRlgo57XM0Xw+Lk1qpcLan/ShIAv5kddlgfzHBSh5YDvDQtp8r6Y+l9qpqDFqAjObNxM9PXNnZS4QKkbBwZXVvW1epUuvQK/6pRQ68PJzf9Fitv/rKtyAAf8FwpDO0YgV5+uprzJXX407FKVY6MBj/8iz7o3opVOTF42q+hUmclNadzryJLTP/DFpBMeRnH2Qdq9zVS45M7rqGpC21OPUJHiE/16xQlaCxniksysxeEJSZl6+jtezxII15uKnVYVhxFi6RnrS7YhUxNreoZ3rCU2XJVeIRb5Q1zX7jfV/NpuHP+oLuulKGQIpko5+1je/iGY4R8acGZpceOPiYLSxpOOyR6o1viFgOyvAu6iB5au2BV6JfuNI/P0zUz4dGbO+pA7YNMhlPBa9gbvt+u5mWgrEU4eMij2xGs8YRw6metEw66UPRYqQ85Ee1Gum6oiynzwpaJhP8EjPtzh+i2Wg8yl9ub61ctCFARoRbNpfKbv6Pw25UlHFWOfh6CVDwwT4bI8m2b7eZJ4iBXoaayHEfThp7UVtWk6+Q4Jz2XAYUSD0ZrfOpJt+XLudbUfSB5bU/5DxoDkW5lo9/2Tlo27ll/5rdCVDedTubgiBBdV9MkSnkCSfF4aUW6ET0kMm1Ailp7m3G6m2rsu9I9FW9aeH7p4dhyOIxTYVtFlbaMm9GiAobBquSwFfVA9qjVsLGOgAyiS7uONy6ZL6RCLvjpa2eBM8lDbzoTHGinWlAop+IZX8e3PqXj4pRpYhIHlYbd/yN/SUcSpmTVpKbqgSIhEiTkyMizALes8dyPw9iy9Wt40XJhLnFGL7RT/MraK0Px7uS4YshqhpHkWsPqA5QJIMxPNbBYUe8Z1EDM8CXVLQxxy5KhKfrzoaWnYdNmRBXLobUIYyk7KLBur+hlGddGPDWaRfOtIIU5fqfXF5qVPVeK2WAtMnEM/iVZVrJuHlWYG2GTq0F/vC5tLHr5wMPcgHDuLIkny9R9JNGoXD++klQqhgZ6eMB3VnuXYZVKbaMy0AnzIuhu59o4FRd250X9YUvaSD67DARld10UMF1opLFsVntIlfRe9Oxv2tkhrKCI68Tg9D9W+PmwuCc8ZEcLRGot2uGje9oRKV/4Tc4B+Us6qQXKXgM4B1W7A1o/jDYMoCQo0zS0ii4V+rhLCcqivSS4nTSiUJB1n7tkpkBM+GCLHpTMMZ9u7MN7anpTPprsJqvxy+X3AjJ/c0LcHp3ygRj+1AC5QRP0KL+0RBplqD3H0P8O04yI9pbajsrfbPDhkV38VCnm3xYC2WNcVjn4AAABhWlDQ1BJQ0MgUFJPRklMRQAAeJx9kT1Iw0AcxV9TpaKVDnYQcchQXbQgWsRRqlgEC6Wt0KqDyaUfQpOGJMXFUXAtOPixWHVwcdbVwVUQBD9AnBydFF2kxP8lhRYxHhz34929x907QGhUmGp2TQCqZhnpRFzM5VfEwCv6EEIAY4hJzNSTmYUsPMfXPXx8vYvyLO9zf45+pWAywCcSzzLdsIjXiac3LZ3zPnGYlSWF+Jx43KALEj9yXXb5jXPJYYFnho1seo44TCyWOljuYFY2VOIYcURRNcoXci4rnLc4q5Uaa92TvzBY0JYzXKc5jAQWkUQKImTUsIEKLERp1Ugxkab9uId/yPGnyCWTawOMHPOoQoXk+MH/4He3ZnFq0k0KxoHuF9v+GAECu0Czbtvfx7bdPAH8z8CV1vZXG8DMJ+n1thY5AkLbwMV1W5P3gMsdYPBJlwzJkfw0hWIReD+jb8oDA7dA76rbW2sfpw9AlrpaugEODoHREmWveby7p7O3f8+0+vsBydRyyjXk7U0AAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfkCw8HLBfRHyqfAAAGWklEQVRYw71XT2zaaBb/PNDEgApVAzgYB4MdwBgouAQLHAwUQiiCplEoNNOSjbbtoVEPOXSrBlUrVZUqjdTsebQzsx3Npcv2MHfU3VXLrdL0uKjazVZJG6VJmiYZJ5GSUuXbS6lIJpA/mh1L7+Df5+/5+X3vvd/PAEIIDmuDg4OdNE2/BwBAAACkKOpdIpHQH8XXF+AI18rKSn5ra+s1AKAHANDz4cOH2Y2NjeGj+DpSAFNTU1GNRlOGEL6AEL5Qq9Xl6enp6K8WwNDQEONwOH6Xy+VUu9cymYz+48ePcbVa/ayOaTSaZ9vb2/FkMqnf/fzAwICqu7t7NJvNMntGsPtMxsbGQg6HY91ut88TBDEXDocLEEJw6dKltMFgKLe3t0Mcx2fu3Lmjqu8pFouqrq6uGYVCAY1GYzmfz2cghKC3t7dgMBjeMgwzzzDM+vXr10O737fjRhAEi8fjWRZFcWJ1dVUWiUTGSZKUGIZ5ZzQaJYfDMRmPx23NCiqRSNg8Hs8kQRASTdPvzGazFI1GxyVJkoXD4QmPx7McDAYtTQPAcXzEbrfPS5Ikq2PxeFwXDoeLV65c0R60sq9du6aNRCLFvr4+XR17//69jGGYeZIkR5oGYLfblQaDYS4ajY4fpaVamSiK41ardc7v9yubBgAhBH19fQWz2SwlEgldk6/zu1yub3Q63RSCIBBBEMhx3H+cTufXhULBv9eec+fO6bu6uiRRFL9sWQN1czgcyz09PbcbMavVqgwEAg8xDKvxPP9Xv98/BADwAQB8g4ODwxzHlbRabe306dM/HD9+fMdXsixb1Ov1i3u96xdANptNEwQhXb16VdvgQAkAqNA0XU0mk2yzNKdSKdZms1Xb2toqOI5/DiKdTms7OjqkCxcuZPYNgCCIssvlmmzEwuHwX0wmU/XevXsn9jvr+/fvnyBJssrz/MNdWZjEcbzcMoBUKqVvb2+HiUTic6tdvHiRoyhqWxAE9qAFFwwGWYvFsp3L5bg61t/fb0NRFKZSqR2cgcRiMf3m5ubw69evo7VaLS6Xy1dnZ2fJ+qDief4bBEHUz58/P9Ss53m+JEnSysuXL8fqWHd398z6+voJmUz2D5IknyqVypL81atX/6rVarNqtbqs0Wi+jUajlUZHS0tLMYVC8YfDzviNjY0SiqKTjdjIyAj75MmT8OrqauTNmze/l8vlfwSfKNXXLJ0IgrRcb2YAAB+CILDVOgAA7suGCIKA/+clN5vNS7Va7TuWZctqtfqZKIqVBw8ebNQf8Hq9U5ubm10AgBeHccyybJdMJvtvIzYxMaGqVCphSZIiBEEkjx07tvQFTdNOi8Xy/dramm1mZqb06NGjauOmra2tv6tUqkOLDZVKNdzW1vbPRuzx48fV6enp0srKis1kMn1P07TzF22IoihsZLzR0VH/YdswFos5KYrazmQyXAMX2FAUhQMDA/qWgwjH8TLLsjsGkd/v/8FkMlXv3r277yC6efPmCbfb/e9gMPhwF9FNms3m8r6TMJ/PZ4xGo9RIvydPnlQCACpms7kaiUSaZsLpdDq8Xm8VAFChKErZMN61GIZJ/f39qQOREU3T70RRLDZiDMMoA4HAdx0dHTWe50vnz58fRhDEhyCILxQKXbDZbH/DMGyb5/lvXS7XDjLiOO52Z2fnwcgoEAgUSJKU8vn8njK7UChwPp/vzy6X6zMde73eKYZhvr58+TK3156zZ8/qLBaLFAqFWtNxOp1WdXZ2vhUE4VcXJNFodNxqtc6dOnWquSChKGrUbrfPLywsyBrISC+K4qEkWTab1Xo8ntuNWZQkScYwzLzRaGwuyT7J8fVQKDSxuLgo6+3tHSdJUsIwbLEuSmOxmK2F7LK53e4/YRgmud3uFZPJJAmCML6wsCALh8MTHMcth0IhS8saGBsbC3k8nmW73T5vtVrnBEH4EkIIcrlcBsfxMoqiEMfxmWKx+FmW37p1S0XT9AyKopAgiPLQ0FAaQgjOnDlTIAjiLcMw8y6Xa/3GjRuhA3WBIAgWnU5XCAQCyj0KSo9h2M/BYDDVwP8pg8Hw8+4h8+k4VBqNZqRQKDAH6oKDGI7jP7Is+1WD2vnKaDT++Jv9nJpMpqeSJCXrc2BtbS1JUdTT3+znVKFQlORyOQEA+AkA8JNcLidQFC0dxdf/AHMc45u0czTdAAAAAElFTkSuQmCC',
        onclick: showSettings
      })
    )
  )
  let current
  bgHsl.subscribe(() => {
    if (current)
      current.style.background = `hsl(${bgHsl().h}, ${bgHsl().s}%, ${bgHsl().l}%)`
  })

  lavaFuzziness.subscribe(() => {
    if (current)
      current.firstChild.style.filter = `blur(${lavaFuzziness()}px)`
  })
  const showSettings = () =>
    document.body.append(settings)

  const animateLava = (lamp) => {
    const createLava = (i) => {
      const lava = div({
        style: {
          backgroundColor: 'orange',
          width: `${lavaSize()}px`,
          height: `${lavaSize()}px`,
          borderRadius: '50%',
          position: 'fixed',
          left: 0,
          right: 0
        }
      })

      //set initial positions for each particle
      state.x[i] = randomBetween(0, size)
      state.y[i] = randomBetween(0, size)
      state.vx[i] = 0
      state.vy[i] = 0
      state.temp[i] = randomNormalDistribution(0, maxTemp()/3)
      state.elements[i] = lava
      state.elements[i].id = `lava-${i}`
      lamp.append(state.elements[i])
    }
    let last = 0
    const canvasRect = {
      w: size,
      h: size,
      l: 0,
      r: size,
      t: 0,
      b: size
    }
    const particleMap = new SpatialHashMap(GRID_CELLS, GRID_CELLS)
    const newState = () => ( {
      x: new Float32Array(particleCount()), // x location
      y: new Float32Array(particleCount()), // y location
      vx: new Float32Array(particleCount()), // horizontal velocity
      temp: new Float32Array(particleCount()),
      vy: new Float32Array(particleCount()), // vertical velocity
      p: new Float32Array(particleCount()), // pressure
      pNear: new Float32Array(particleCount()), // pressure near
      g: new Float32Array(particleCount()), // 'nearness' to neighbour
      elements: []
    } )
    const state = newState()
    const applyGlobalForces = (i) => {
      const force = [gravity[0] + DEVICE_FORCE[0], gravity[1] + DEVICE_FORCE[1]]
      // const force = DEVICE_FORCE
      state.vx[i] += force[0]
      state.vy[i] += force[1]
      let distanceFromHeatSource = canvasRect.b - state.y[i]
      if (distanceFromHeatSource < 5) {
        distanceFromHeatSource = 5
      }
      if (state.temp[i] > 0) {
        const tempDecrease = randomNormalDistribution(1, 15) * ( canvasRect.h - state.y[i] ) / (ambientTemp()*100)
        state.temp[i] -= tempDecrease
      }
      if (distanceFromHeatSource < 100 && state.temp[i] < maxTemp()) {
        const tempIncrease = (randomNormalDistribution(1, 100) / distanceFromHeatSource)/2 * lampTemp()/100
        state.temp[i] += tempIncrease
        const radius = ( interactionRadius() / canvasRect.w ) * GRID_CELLS
        let neighbors = particleMap.query(state.x[i], state.y[i], radius*2)
        const neighborTempIncrease = state.temp[i] * 2 / neighbors.length
        for (const k of neighbors) {
          if (state.temp[k] < maxTemp()) {
            state.temp[k] += neighborTempIncrease
            state.vy[k] -= state.temp[k]
          }
        }
      }
      if (state.temp[i] > maxTemp()) {
        state.temp[i] = maxTemp()
      }
      if (state.temp[i] < 0) {
        state.temp[i] = 0
      }
      state.vy[i] -= state.temp[i]
    }
    const gradient = (i, n) => {
      const particle = [state.x[i], state.y[i]] // position of i
      const neighbour = [state.x[n], state.y[n]] // position of n

      const lsq = lengthSq(subtract(particle, neighbour))
      if (lsq > interactionRadiusSq) return 0

      const distance = Math.sqrt(lsq)
      return 1 - distance / interactionRadius()
    }

    const subtract = ([x1, y1], [x2, y2]) => [x1 - x2, y1 - y2]
    const lengthSq = ([x, y]) => x * x + y * y
    const multiplyScalar = ([x, y], r) => [x * r, y * r]

    //approximate unit vector
    //https://www.h3xed.com/programming/fast-unit-vector-calculation-for-2d-games
    const unitApprox = (t) => {
      if (0 === t[0] && 0 === t[1]) return [0, 0]
      const ax = Math.abs(t[0]), ay = Math.abs(t[1])
      let ratio = 1 / Math.max(ax, ay)
      ratio *= 1.29289 - ( ax + ay ) * ratio * 0.29289
      return multiplyScalar(t, ratio)
    }

    const getNeighboursWithGradients = i => {
      const gridX = Math.floor(state.x[i] / GRID_CELLS),
        gridY = Math.floor(state.y[i] / GRID_CELLS)
      const radius = ( interactionRadius() / canvasRect.w ) * GRID_CELLS

      const results = particleMap.query(gridX, gridY, radius)
      const neighbours = []

      for (let k = 0; k < results.length; k++) {

        const n = results[k]
        if (i === n) continue // Skip itself

        const g = gradient(i, n)
        if (g === 0) continue

        state.g[n] = g // Store the gradient
        neighbours.push(n) // Push the neighbour to neighbours

      }

      return neighbours
    }

    const updatePressure = (i, neighbours) => {
      let density = 0
      let nearDensity = 0

      for (let k = 0; k < neighbours.length; k++) {
        const g = state.g[neighbours[k]] // Get g for this neighbour
        density += g * g
        nearDensity += g * g * g
      }
      state.p[i] = stiffness() * ( density - restDensity() )
      state.pNear[i] = stiffnessNear() * nearDensity
    }

    const relax = (i, neighbours, dt) => {
      const pos = [state.x[i], state.y[i]]

      for (let k = 0; k < neighbours.length; k++) {
        const n = neighbours[k]
        const g = state.g[n]

        const nPos = [state.x[n], state.y[n]]
        const magnitude = state.p[i] * g + state.pNear[i] * g * g

        const direction = unitApprox(subtract(nPos, pos))
        const force = multiplyScalar(direction, magnitude)

        const d = multiplyScalar(force, dt * dt)

        state.x[i] += d[0] * -1
        state.y[i] += d[1] * -1

        state.x[n] += d[0] * .1
        state.y[n] += d[1] * .1
      }
    }

    const contain = (i) => {
      if (state.x[i] > size) {
        state.x[i] = size
        state.vx[i] = 0
      }
      if (state.x[i] < 0) {
        state.x[i] = 0
        state.vx[i] = 0
      }
      if (state.y[i] > size) {
        state.y[i] = size
        state.vy[i] = 0
      }
      if (state.y[i] < 0) {
        state.y[i] = 0
        state.vy[i] = 0
      }
    }

    function run (dt) {
      particleMap.clear()
      DEVICE_FORCE[0] = ( deviceAcceleration[0] / dt ) * 2
      DEVICE_FORCE[1] = ( deviceAcceleration[1] / dt ) * 2
      deviceAcceleration[0] = 0
      deviceAcceleration[1] = 0
      for (let i = 0; i < particleCount(); i++) {
        applyGlobalForces(i)
        state.x[i] += state.vx[i] * dt
        state.y[i] += state.vy[i] * dt
        const gridX = Math.floor(state.x[i] / GRID_CELLS),
          gridY = Math.floor(state.y[i] / GRID_CELLS)
        particleMap.add(gridX, gridY, i)
      }
      for (let i = 0; i < particleCount(); i++) {
        let neighbours = getNeighboursWithGradients(i)
        updatePressure(i, neighbours)
        relax(i, neighbours, dt)
        contain(i)
        state.elements[i].style.transform = `translate(${state.x[i]}px, ${state.y[i]}px)`
        state.vx[i] = 0
        state.vy[i] = 0
      }
    }

    function render (time) {
      // run((time - last)/1000)
      run(1/60)
      last = time
      requestAnimationFrame(render)
    }

    window.addEventListener('deviceorientation', function (n) {
      // GRAVITY[0] = ( n.gamma / 90 ) * gravityStrength * 1.33
      // GRAVITY[1] = ( -n.beta / 90 ) * gravityStrength * 1.33
    })
    window.addEventListener('devicemotion', function (n) {
      deviceAcceleration[0] += n.acceleration.x
      deviceAcceleration[1] += n.acceleration.y
    })
    lavaSize.subscribe(() => {
      for (const el of state.elements) {
        el.style.width = `${lavaSize()}px`
        el.style.height = `${lavaSize()}px`
      }
    })
    gravityStrength.subscribe((newStrength, old) => {
      gravity[1] = newStrength
      const diff = newStrength - old
      for(let i = 0; i<state.vy.length; i++){
        state.vy[i] += diff
      }
    })
    particleCount.subscribe(() => {
      console.log('start length', state.elements.length)
      console.log('new count', particleCount())
      if (state.elements.length > particleCount()) {
        for (let i = particleCount(); i < state.elements.length; i++) {
          state.elements[i].remove()
        }
        state.elements = state.elements.slice(0, particleCount())
      } else if (state.elements.length < particleCount()) {
        const updatedState = newState()
        for (const f of Object.keys(state)) {
          for (let i = 0; i < state[f].length; i++) {
            updatedState[f][i] = state[f][i]
          }
          state[f] = updatedState[f]
        }
        for (let i = state.elements.length; i < particleCount(); i++) {
          createLava(i)
        }
      }
      particleMap.clear()
      for (let i = 0; i < particleCount(); i++) {
        const gridX = Math.floor(state.x[i] / GRID_CELLS),
          gridY = Math.floor(state.y[i] / GRID_CELLS)
        particleMap.add(gridX, gridY, i)
      }
      console.log('end length', state.elements.length)
      console.log('new count', particleCount())
    })

    for (let i = 0; i < particleCount(); i++) {
      createLava(i)
      const gridX = Math.floor(state.x[i] / GRID_CELLS),
        gridY = Math.floor(state.y[i] / GRID_CELLS)
      particleMap.add(gridX, gridY, i)
    }

    render(1)
  }

  const reset = () => {
    if (current) current.remove()
    let lamp = lavalamp()
    document.body.append(current = bg(lamp))
    animateLava(lamp)
  }

  document.body.append(sub(
    {
      style: {
        'font-size': '10px',
        position: 'fixed',
        bottom: '2px',
        left: '2px',
        'z-index': 200
      }

    },
    a({
      target: '_blank',
      href: 'https://github.com/narcolepticsnowman/lavalamp.app'
    }, 'Copyright © 2020 Robert Kempton')
  ))

  reset()

</script>
</body>
</html>
