<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lavalamp.app</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body style="font-family: Arial">
<svg id="settings" fill="white" viewBox="0 0 24 24" width="36" height="36">
    <path d="M10.7,2.625a3.481,3.481,0,0,0-6.3,0H0v3H4.395a3.481,3.481,0,0,0,6.3,0H24v-3Z"/>
    <path d="M16.455,8.5a3.492,3.492,0,0,0-3.151,2H0v3H13.3a3.481,3.481,0,0,0,6.3,0H24v-3H19.605A3.492,3.492,0,0,0,16.455,8.5Z"/>
    <path d="M7.545,16.375a3.492,3.492,0,0,0-3.15,2H0v3H4.395a3.481,3.481,0,0,0,6.3,0H24v-3H10.7A3.492,3.492,0,0,0,7.545,16.375Z"/>
</svg>
<script src="https://cdn.jsdelivr.net/npm/nosleep.js@0.11.0/dist/NoSleep.min.js"></script>
<script type="module">
  import {
    button,
    div,
    input,
    label,
    canvas,
    a,
    sub
  } from 'https://cdn.jsdelivr.net/npm/@srfnstack/fntags@0.3.8/src/fnelements.min.mjs'
  import { fnstate } from 'https://cdn.jsdelivr.net/npm/@srfnstack/fntags@0.3.8/src/fntags.min.mjs'

  const noSleep = new NoSleep()

  const clamp = (value, min, max) => Math.min(Math.max(value, min), max)

  // borrowed from https://gist.github.com/peeke/e65e8c162a22b21ac9ac9de07a4afeac
  class SpatialHashMap {
    constructor (width, height) {
      this.width = width
      this.height = height
      this.grid = new Array(width * height).fill(null).map(() => [])
    }

    clear () {
      this.grid.forEach(cell => {
        cell.splice(0)
      })
    }

    add (x, y, data) {
      x = clamp(Math.round(x), 0, this.width - 1)
      y = clamp(Math.round(y), 0, this.height - 1)

      const index = x + y * this.width
      let cell = this.grid[index]
      cell.push(data)
    }

    query (x, y, radius) {
      if (radius) {
        return this.queryWithRadius(x, y, radius)
      }

      x = clamp(Math.round(x), 0, this.width - 1)
      y = clamp(Math.round(y), 0, this.height - 1)

      const index = x + y * this.width
      return this.grid[index]
    }

    queryWithRadius (x, y, radius) {
      const left = Math.max(Math.round(x - radius), 0)
      const right = Math.min(Math.round(x + radius), this.width - 1)
      const bottom = Math.max(Math.round(y - radius), 0)
      const top = Math.min(Math.round(y + radius), this.height - 1)

      const result = []

      for (let i = left; i <= right; i++) {
        for (let j = bottom; j <= top; j++) {
          const query = this.query(i, j)
          for (let k = 0; k < query.length; k++) {
            result.push(query[k])
          }
        }
      }

      return result
    }
  }

  function enableNoSleep () {
    document.removeEventListener('click', enableNoSleep, false)
    noSleep.enable()
    notify('Wake Lock Activated')
  }

  function notify (...message) {
    let notification = div(
      {
        style: {
          position: 'fixed',
          bottom: '20px',
          left: '20px',
          width: '25vw',
          'min-width': '250px',
          background: 'rgb(220,220,220,.6)',
          'text-align': 'center',
          'line-height': '100px',
          'font-size': '25px',
          'z-index': 100,
          'border-radius': '8px'
        }
      },
      ...message
    )
    document.body.append(notification)
    let notifyTime = 2000
    notification.animate(
      [
        { opacity: 1 },
        { opacity: 0 }
      ],
      notifyTime
    )
    notification.style.opacity = 0
    setTimeout(() => notification.remove(), notifyTime)
  }

  document.addEventListener('click', enableNoSleep, false)
  const defaultBgColor = { r: 0, g: 0, b: 0 }
  const defaultLavaColor = { r: 255, g: 0, b: 0 }
  const defaultLavaHighlight = { r: 255, g: 200, b: 0 }
  const defaultParticleCount = fnstate(Math.min(Math.trunc(window.innerHeight * window.innerWidth / 3000), 600))
  const defaultInteractionRadius = 50
  const defaultStiffness = 3000
  const defaultStiffnessNear = 8000
  const defaultRestDensity = 5.45
  const defaultParticleSize = 30
  const defaultMaxTemp = fnstate(Math.min(window.innerHeight, 1200))
  const defaultGravityStrength = fnstate(Math.min(window.innerHeight/2, 600))
  const GRID_CELLS = 54

  const bgColor = fnstate({ r: 0, g: 0, b: 0 })
  const lavaColor = fnstate({ r: 255, g: 0, b: 0 })
  const highlightColor = fnstate({ r: 255, g: 200, b: 0 })
  const interactionRadius = fnstate(defaultInteractionRadius)
  const gravityStrength = fnstate(defaultGravityStrength())
  const stiffness = fnstate(defaultStiffness)
  const stiffnessNear = fnstate(defaultStiffnessNear)
  const restDensity = fnstate(defaultRestDensity)
  const maxTemp = fnstate(defaultMaxTemp())
  const particleCount = fnstate(defaultParticleCount())
  const particleSize = fnstate(defaultParticleSize)
  const gravity = [0, gravityStrength()]
  const DEVICE_FORCE = [0, 0]
  const deviceAcceleration = [0, 0]
  let interactionRadiusSq = interactionRadius() * interactionRadius()

  interactionRadius.subscribe(() => {
    interactionRadiusSq = interactionRadius() * interactionRadius()
  })

  const applySettings = obj => {
    bgColor(obj.bgColor || Object.assign({}, defaultBgColor))
    lavaColor(obj.lavaColor || Object.assign({}, defaultLavaColor))
    highlightColor(obj.lavaHighlight || Object.assign({}, defaultLavaHighlight))
    interactionRadius(obj.interactionRadius || interactionRadius())
    gravityStrength(obj.gravityStrength || gravityStrength())
    stiffness(obj.stiffness || stiffness())
    stiffnessNear(obj.stiffnessNear || stiffnessNear())
    restDensity(obj.restDensity || restDensity())
    maxTemp(obj.maxTemp || maxTemp())
    particleCount(obj.particleCount || particleCount())
    particleSize(obj.particleSize || particleSize())
  }

  const getSettings = () => ( {
    bgColor: bgColor(),
    lavaColor: lavaColor(),
    lavaHighlight: highlightColor(),
    interactionRadius: interactionRadius(),
    gravityStrength: gravityStrength(),
    stiffness: stiffness(),
    stiffnessNear: stiffnessNear(),
    restDensity: restDensity(),
    maxTemp: maxTemp(),
    particleCount: particleCount(),
    particleSize: particleSize(),
  } )

  let settingsKey = 'lavalamp.app-settings'
  if (localStorage.getItem(settingsKey)) {
    applySettings(JSON.parse(localStorage.getItem(settingsKey)))
  }

  const urlParams = new URLSearchParams(window.location.search)
  if (urlParams.get('shared')) {
    try {
      applySettings(JSON.parse(atob(urlParams.get('shared'))))
    } catch {
      notify('Invalid Share URL')
    }
  }

  const saveSettings = () => {
    localStorage.setItem(
      settingsKey,
      JSON.stringify(getSettings())
    )
    settings.remove()
  }

  const resetDefaults = () => {
    if (confirm('This will reset ALL defaults and remove saved settings')) {
      localStorage.removeItem(settingsKey)
      bgColor(Object.assign({}, defaultBgColor))
      lavaColor(Object.assign({}, defaultLavaColor))
      highlightColor(Object.assign({}, defaultLavaHighlight))
      interactionRadius(defaultInteractionRadius)
      gravityStrength(defaultGravityStrength())
      stiffness(defaultStiffness)
      stiffnessNear(defaultStiffnessNear)
      restDensity(defaultRestDensity)
      maxTemp(defaultMaxTemp())
      particleCount(defaultParticleCount())
      particleSize(defaultParticleSize)
    }
  }

  const randomBetween = (min, max) => Math.trunc(Math.random() * ( max - min ) + min)

  function randomNormalDistribution (min, max, skew = 1) {
    let u = 0, v = 0
    while (u === 0) {
      u = Math.random()
    } //Converting [0,1) to (0,1)
    while (v === 0) {
      v = Math.random()
    }
    let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)

    num = num / 10.0 + 0.5 // Translate to 0 -> 1
    if (num > 1 || num < 0) num = randomNormalDistribution(min, max, skew) // resample between 0 and 1 if out of range
    num = Math.pow(num, skew) // Skew
    num *= max - min // Stretch to fill range
    num += min // offset to min
    return Math.trunc(num)
  }

  function hexToRgb (hex) {
    const bigint = parseInt(hex.slice(1), 16)
    return {
      r: ( bigint >> 16 ) & 255,
      g: ( bigint >> 8 ) & 255,
      b: bigint & 255
    }
  }

  function rgbToHex (color) {
    return `#${( 1 << 24 | color.r << 16 | color.g << 8 | color.b ).toString(16).slice(1)}`
  }

  const formInput = (inputLabel, theInput, setDefault) => {
    theInput.style.cursor = 'pointer'
    return div(
      {
        style: {
          display: 'flex',
          'flex-direction': 'row',
          'width': '100%',
          margin: '10px',
          'justify-content': 'space-between'
        }
      },
      label({ for: theInput.getAttribute('id') }, inputLabel),
      div(
        {
          style: {
            display: 'flex',
            'flex-direction': 'row'
          }
        },
        theInput,
        setDefault ? setDefault : ''
      )
    )
  }
  let id = 0
  const resetToDefaultButton = (clickHandler, style) => div(
    {
      onclick: clickHandler,
      tooltip: 'Reset To Default',
      style: Object.assign({
        cursor: 'pointer',
        'margin-right': '-10px',
        'margin-left': '20px'
      }, style)
    },
    'x'
  )

  const copyShareLink = () =>
    navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}?shared=${btoa(JSON.stringify(getSettings()))}`)
      .then(function () {
        notify('Link Copied to Clipboard')
      }, function (err) {
        notify('Failed to Copy Share Link...')
        console.error(err)
      })

  const settings = div({
      style: {
        float: 'left',
        background: 'rgb(150,150,150,.6)',
        'z-index': 20,
        padding: '22px 22px',
        display: 'flex',
        position: 'relative',
        'max-width': '700px',
        'border-radius': '10px',
        'flex-direction': 'column',
        'justify-content': 'space-evenly',
        'align-items': 'center'
      }
    },
    formInput(
      'Background Color',
      input({
        id: 'bgColor',
        type: 'color',
        value: bgColor.bindAttr(() => rgbToHex(bgColor())),
        oninput: e => bgColor(hexToRgb(e.target.value))
      })
    ),
    formInput(
      'Lava Color',
      input({
        id: 'lavaColor',
        type: 'color',
        value: lavaColor.bindAttr(() => rgbToHex(lavaColor())),
        oninput: e => lavaColor(hexToRgb(e.target.value))
      })
    ),
    formInput(
      'Highlight Color',
      input({
        id: 'highlightColor',
        type: 'color',
        value: highlightColor.bindAttr(() => rgbToHex(highlightColor())),
        oninput: e => highlightColor(hexToRgb(e.target.value))
      })
    ),
    formInput(
      'Particle Size',
      input({
        id: 'particleSize',
        type: 'range',
        min: 5,
        step: 1,
        max: 50,
        value: particleSize.bindAttr(particleSize),
        oninput: (e) => particleSize(e.target.value)
      }),
      resetToDefaultButton(() => particleSize(defaultParticleSize))
    ),
    formInput(
      'Particle Count',
      input({
        id: 'particle-count',
        type: 'range',
        value: particleCount.bindAttr(),
        step: 1,
        min: 5,
        max: defaultParticleCount.bindAttr(() => Math.trunc(defaultParticleCount()) * 2),
        oninput: (e) => particleCount(parseInt(e.target.value))
      }),
      resetToDefaultButton(() => particleCount(defaultParticleCount))
    ),
    formInput(
      'Interaction Radius',
      input({
        id: 'interaction-radius',
        type: 'range',
        value: interactionRadius.bindAttr(),
        step: 1,
        min: 30,
        max: 100,
        oninput: (e) => interactionRadius(e.target.value)
      }),
      resetToDefaultButton(() => interactionRadius(defaultInteractionRadius))
    ),
    formInput(
      'Stiffness',
      input({
        id: 'stiffness',
        type: 'range',
        value: stiffness.bindAttr(),
        step: 1,
        min: 1,
        max: 6500,
        oninput: (e) => stiffness(e.target.value)
      }),
      resetToDefaultButton(() => stiffness(defaultStiffness))
    ),
    formInput(
      'Stiffness Near',
      input({
        id: 'stiffness-near',
        type: 'range',
        value: stiffnessNear.bindAttr(),
        step: 10,
        min: 1,
        max: 40000,
        oninput: (e) => stiffnessNear(e.target.value)
      }),
      resetToDefaultButton(() => stiffnessNear(defaultStiffnessNear))
    ),
    formInput(
      'Rest Density',
      input({
        id: 'rest-density',
        type: 'range',
        value: restDensity.bindAttr(),
        step: .01,
        min: .01,
        max: 7,
        oninput: (e) => restDensity(e.target.value)
      }),
      resetToDefaultButton(() => restDensity(defaultRestDensity))
    ),
    formInput(
      'Max Temp',
      input({
        id: 'max-temp',
        type: 'range',
        value: maxTemp.bindAttr(),
        step: 1,
        min: 420,
        max: defaultMaxTemp.bindAttr(() => defaultMaxTemp() * 2),
        oninput: (e) => maxTemp(e.target.value)
      }),
      resetToDefaultButton(() => maxTemp(defaultMaxTemp()))
    ),
    formInput(
      'Gravity Strength',
      input({
        id: 'gravity',
        type: 'range',
        value: gravityStrength.bindAttr(),
        step: 1,
        min: 220,
        max: defaultGravityStrength.bindAttr(() => defaultGravityStrength() * 2),
        oninput: (e) => gravityStrength(parseFloat(e.target.value))
      }),
      resetToDefaultButton(() => gravityStrength(defaultGravityStrength()))
    ),
    formInput(
      'Share',
      button({
        id: 'share', onclick: copyShareLink,
        style: {
          'border-radius': '5px',
          padding: '5px'
        }
      }, 'Share')
    ),
    formInput(
      'Save',
      button({
        id: 'save', onclick: saveSettings,
        style: {
          'border-radius': '5px',
          padding: '5px'
        }
      }, 'Save and Close')
    ),
    formInput('Reset Defaults', button({
      id: 'reset', onclick: resetDefaults,
      style: {
        'border-radius': '5px',
        padding: '5px'
      }
    }, 'Reset Defaults')),
    div({
        style: {
          position: 'absolute',
          top: '10px',
          right: '20px',
          'font-style': 'sans-serif',
          'font-size': '26px',
          cursor: 'pointer'
        },
        onclick: () => settings.remove()
      },
      'x'
    )
  )

  let lavalamp = () => canvas(
    {
      id: 'lavalamp',
      width: 600,
      height: 600,
      style: {
        filter: `blur(1px)`
      }
    })

  const settingsSVG = document.getElementById('settings')
  const showSettings = () =>
    document.body.append(settings)
  settingsSVG.addEventListener('click', showSettings)
  const bg = (lamp) => div({
      style: {
        position: 'fixed',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        filter: 'brightness(.9) contrast(10)',
        'z-index': -100,
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        background: bgColor.bindStyle(() => `rgb(${bgColor().r}, ${bgColor().g}, ${bgColor().b})`)
      }
    },
    lamp,
    div(
      {
        style: {
          position: 'fixed',
          top: '10px',
          left: '20px',
          cursor: 'pointer',
          'z-index': 10
        }
      },
      settingsSVG
    )
  )

  const animateLava = (lamp) => {
    lamp.addEventListener('click', () => {
      if (settings.parentNode) {
        settings.remove()
      }
    })
    const context = lamp.getContext('2d')
    const tmpCanvas = canvas()
    let height = lamp.height = tmpCanvas.height = Math.min(window.innerHeight, 1200)
    let width = lamp.width = tmpCanvas.width = Math.min(window.innerWidth, 1200)
    const calcSlope = (x1, y1, x2, y2) => ( y2 - y1 ) / ( x2 - x1 )
    const lineEq = (slope, x1, y1) => {
      const b = y1 - slope * x1
      return (x) => slope * x + b
    }
    let leftBottomEnd = width * .45
    let rightBottomStart = width * .55
    let bottomStart = height * .7
    let leftBottomSlope = calcSlope(0, bottomStart, leftBottomEnd, height)
    let leftBottomLine = lineEq(leftBottomSlope, 0, bottomStart)
    let rightBottomSlope = calcSlope(rightBottomStart, height, width, bottomStart)
    let rightBottomLine = lineEq(rightBottomSlope, rightBottomStart, height)

    window.addEventListener('resize', () => {
      height = lamp.height = tmpCanvas.height = Math.min(window.innerHeight, 1200)
      width = lamp.width = tmpCanvas.width = Math.min(window.innerWidth, 1200)
      leftBottomEnd = width * .45
      rightBottomStart = width * .55
      bottomStart = height * .7
      leftBottomSlope = calcSlope(0, bottomStart, leftBottomEnd, height)
      leftBottomLine = lineEq(leftBottomSlope, 0, bottomStart)
      rightBottomSlope = calcSlope(rightBottomStart, height, width, bottomStart)
      rightBottomLine = lineEq(rightBottomSlope, rightBottomStart, height)
      const currentDefaultParticleCount = defaultParticleCount()
      defaultParticleCount(Math.min(Math.trunc(width * height / 1000), 1000))
      if (particleCount() === currentDefaultParticleCount) {
        particleCount(defaultParticleCount())
      }
      const currentDefaultGravityStrength = defaultGravityStrength()
      defaultGravityStrength(Math.min(window.innerHeight/ 2, 600))
      if(gravityStrength() === currentDefaultGravityStrength){
        gravityStrength(defaultGravityStrength())
      }

    })
    const tmpContext = tmpCanvas.getContext('2d', { willReadFrequently: true })

    const highlightHeight = 15
    const initLava = (i) => {
      //set initial positions for each particle
      state.x[i] = randomBetween(0, width)
      state.y[i] = randomBetween(bottomStart, height)
      state.vx[i] = 0
      state.vy[i] = 0
      state.temp[i] =  0
    }
    const particleMap = new SpatialHashMap(GRID_CELLS, GRID_CELLS)
    const newState = () => ( {
      x: new Float32Array(particleCount()), // x location
      y: new Float32Array(particleCount()), // y location
      vx: new Float32Array(particleCount()), // horizontal velocity
      temp: new Float32Array(particleCount()),
      vy: new Float32Array(particleCount()), // vertical velocity
      p: new Float32Array(particleCount()), // pressure
      pNear: new Float32Array(particleCount()), // pressure near
      g: new Float32Array(particleCount()), // 'nearness' to neighbour
    } )
    const state = newState()
    const applyGlobalForces = (i) => {
      const force = [gravity[0] + DEVICE_FORCE[0], gravity[1] + DEVICE_FORCE[1]]
      // const force = DEVICE_FORCE
      state.vx[i] += force[0]
      state.vy[i] += force[1]
      let distanceFromHeatSource = height - state.y[i]
      if (distanceFromHeatSource < 1) {
        distanceFromHeatSource = 1
      }
      if (state.temp[i] > 0) {
        const tempDecrease = randomNormalDistribution(1, 100) / 40
        state.temp[i] -= tempDecrease
      }
      if (state.y[i] > bottomStart && state.temp[i] < maxTemp()) {
        const tempIncrease = randomNormalDistribution(1, 300) / 40 / distanceFromHeatSource * distanceFromHeatSource
        state.temp[i] += tempIncrease
        if(state.y[i] > height - particleSize()){
          state.temp[i] += tempIncrease * 3
        }
      }
      //don't share heat when at the top of the lamp, just to reduce the amount of time it takes to sink back down
      // if(state.y[i] > height *.1) {
      //share heat with neighbors to increase blob size
      const radius = ( interactionRadius() / width ) * GRID_CELLS
      let neighbors = particleMap.query(state.x[i], state.y[i], radius)
      const neighborTempIncrease = state.temp[i] / neighbors.length
      for (const k of neighbors) {
        if (state.temp[k] < maxTemp()) {
          state.temp[k] += neighborTempIncrease
          state.vy[k] -= state.temp[k]
        }
      }
      // }
      //make the top and bottom a bit sticky, with the corners being extra sticky
      let edgeStickiness = 10 - 9 * Math.abs(width / 2 - state.x[i]) / width / 2
      if (state.y[i] < particleSize() * 1.5) {
        state.vy[i] -= 15 * edgeStickiness
      }
      if (state.y[i] > particleSize() * 2) {
        state.vy[i] += 10 * edgeStickiness
      }
      if (state.temp[i] > maxTemp()) {
        state.temp[i] = maxTemp()
      }
      if (state.temp[i] < 0) {
        state.temp[i] = 0
      }
      state.vy[i] -= state.temp[i]
    }
    const gradient = (i, n) => {
      const particle = [state.x[i], state.y[i]] // position of i
      const neighbour = [state.x[n], state.y[n]] // position of n

      const lsq = lengthSq(subtract(particle, neighbour))
      if (lsq > interactionRadiusSq) return 0

      const distance = Math.sqrt(lsq)
      return 1 - distance / interactionRadius()
    }

    const subtract = ([x1, y1], [x2, y2]) => [x1 - x2, y1 - y2]
    const lengthSq = ([x, y]) => x * x + y * y
    const multiplyScalar = ([x, y], r) => [x * r, y * r]

    //approximate unit vector
    //https://www.h3xed.com/programming/fast-unit-vector-calculation-for-2d-games
    const unitApprox = (t) => {
      if (0 === t[0] && 0 === t[1]) return [0, 0]
      const ax = Math.abs(t[0]), ay = Math.abs(t[1])
      let ratio = 1 / Math.max(ax, ay)
      ratio *= 1.29289 - ( ax + ay ) * ratio * 0.29289
      return multiplyScalar(t, ratio)
    }

    const getNeighboursWithGradients = i => {
      const gridX = Math.floor(state.x[i] / GRID_CELLS),
        gridY = Math.floor(state.y[i] / GRID_CELLS)
      const radius = ( interactionRadius() / width ) * GRID_CELLS

      const results = particleMap.query(gridX, gridY, radius)
      const neighbours = []

      for (let k = 0; k < results.length; k++) {

        const n = results[k]
        if (i === n) continue // Skip itself

        const g = gradient(i, n)
        if (g === 0) continue

        state.g[n] = g // Store the gradient
        neighbours.push(n) // Push the neighbour to neighbours

      }

      return neighbours
    }

    const updatePressure = (i, neighbours) => {
      let density = 0
      let nearDensity = 0

      for (let k = 0; k < neighbours.length; k++) {
        const g = state.g[neighbours[k]] // Get g for this neighbour
        density += g * g
        nearDensity += g * g * g
      }
      state.p[i] = stiffness() * ( density - restDensity() )
      state.pNear[i] = stiffnessNear() * nearDensity
    }

    const relax = (i, neighbours, dt) => {
      const pos = [state.x[i], state.y[i]]

      for (let k = 0; k < neighbours.length; k++) {
        const n = neighbours[k]
        const g = state.g[n]

        const nPos = [state.x[n], state.y[n]]
        const magnitude = state.p[i] * g + state.pNear[i] * g * g

        const direction = unitApprox(subtract(nPos, pos))
        const force = multiplyScalar(direction, magnitude)

        const d = multiplyScalar(force, dt * dt)

        state.x[i] += d[0] * -1
        state.y[i] += d[1] * -1

        state.x[n] += d[0] * .1
        state.y[n] += d[1] * .1
      }
    }

    const contain = (i) => {
      if (state.x[i] > width) {
        state.x[i] = width
      }
      if (state.x[i] < 0) {
        state.x[i] = 0
      }

      if (state.x[i] < leftBottomEnd && state.y[i] > leftBottomLine(state.x[i])) {
        state.y[i] = leftBottomLine(state.x[i])
        state.x[i] += 4
        state.y[i] += 4
      } else if (state.x[i] > rightBottomStart && state.y[i] > rightBottomLine(state.x[i])) {
        state.y[i] = rightBottomLine(state.x[i])
        state.x[i] -= 4
        state.y[i] += 4
      } else if (state.y[i] > height) {
        state.y[i] = height
      }
      if (state.y[i] < 0) {
        state.y[i] = 0
      }
    }

    function drawLava (i) {
      const gradient = tmpContext.createRadialGradient(state.x[i], state.y[i], 0, state.x[i], state.y[i], particleSize())
      gradient.addColorStop(0, `rgba(${lavaColor().r},${lavaColor().g},${lavaColor().b},1)`)
      gradient.addColorStop(1, `rgba(${lavaColor().r},${lavaColor().g},${lavaColor().b},0)`)
      tmpContext.beginPath()
      tmpContext.fillStyle = gradient
      tmpContext.arc(state.x[i], state.y[i], particleSize(), 0, Math.PI * 2)
      tmpContext.fill()
    }

    function isBottom (pix, row, col) {
      return ( row + 1 < height && pix[pixIndex(row + 1, col) + 3] === 0 ) || row === height - 2
    }

    const pixIndex = (row, col) => row * width * 4 + col * 4

    const addGradient = (pix, i, percent, r = 0, g = 0, b = 0) => {
      const x = 1 - percent
      pix[i] = percent * pix[i] + x * r
      pix[i + 1] = percent * pix[i + 1] + x * g
      pix[i + 2] = percent * pix[i + 2] + x * b
    }

    function drawHighlights (pix) {
      for (let row = 0; row < height; row++) {
        for (let col = 0; col < width; col++) {
          const i = pixIndex(row, col)
          if (pix[i + 3] === 255 && isBottom(pix, row, col, i)) {
            for (let j = 0; j < highlightHeight; j++) {
              let up = pixIndex(row - j, col)
              if (row + j < height && pix[up + 3] === 255) {
                addGradient(pix, up, j / highlightHeight, highlightColor().r, highlightColor().g, highlightColor().b)
              }
              //TODO figure out how to draw gradient border around entire blob
            }
          }
        }
      }
    }

    function updateCanvas () {
      let imageData = tmpContext.getImageData(0, 0, width, height),
        pix = imageData.data
      //set transparency based on cutoff to make metaball effect
      //close enough balls will increase the transparency over the threshold to create the blobbing effect
      for (let row = 0; row < height; row++) {
        for (let col = 0; col < width; col++) {
          const i = row * width * 4 + col * 4
          if (pix[i + 3] > 70) {
            pix[i + 3] = 255
          } else {
            pix[i + 3] = 0
          }
        }
      }
      drawHighlights(pix)
      context.putImageData(imageData, 0, 0)
      tmpContext.clearRect(0, 0, width, height)
    }

    function run (dt) {
      particleMap.clear()
      DEVICE_FORCE[0] = ( deviceAcceleration[0] / dt ) * 2
      DEVICE_FORCE[1] = ( deviceAcceleration[1] / dt ) * 2
      deviceAcceleration[0] = 0
      deviceAcceleration[1] = 0
      for (let i = 0; i < particleCount(); i++) {
        applyGlobalForces(i)
        state.x[i] += state.vx[i] * dt
        state.y[i] += state.vy[i] * dt
        const gridX = Math.floor(state.x[i] / GRID_CELLS),
          gridY = Math.floor(state.y[i] / GRID_CELLS)
        particleMap.add(gridX, gridY, i)
      }
      for (let i = 0; i < particleCount(); i++) {
        let neighbours = getNeighboursWithGradients(i)
        updatePressure(i, neighbours)
        relax(i, neighbours, dt)
        contain(i)
        drawLava(i)
        state.vx[i] = 0
        state.vy[i] = 0
      }
      updateCanvas()
    }

    function render () {
      run(1 / 60)
      requestAnimationFrame(render)
    }

    window.addEventListener('deviceorientation', function (n) {
      // GRAVITY[0] = ( n.gamma / 90 ) * gravityStrength * 1.33
      // GRAVITY[1] = ( -n.beta / 90 ) * gravityStrength * 1.33
    })
    window.addEventListener('devicemotion', function (n) {
      deviceAcceleration[0] += n.acceleration.x
      deviceAcceleration[1] += n.acceleration.y
    })
    gravityStrength.subscribe((newStrength, old) => {
      gravity[1] = newStrength
      const diff = newStrength - old
      for (let i = 0; i < state.vy.length; i++) {
        state.vy[i] += diff
      }
    })
    particleCount.subscribe(() => {
      if (state.x.length < particleCount()) {
        const updatedState = newState()
        const originalLength = state.x.length
        for (const f of Object.keys(state)) {
          for (let i = 0; i < state[f].length; i++) {
            updatedState[f][i] = state[f][i]
          }
          state[f] = updatedState[f]
        }
        for (let i = originalLength; i < particleCount(); i++) {
          initLava(i)
        }
      }
      particleMap.clear()
      for (let i = 0; i < particleCount(); i++) {
        const gridX = Math.floor(state.x[i] / GRID_CELLS),
          gridY = Math.floor(state.y[i] / GRID_CELLS)
        particleMap.add(gridX, gridY, i)
      }
    })

    for (let i = 0; i < particleCount(); i++) {
      initLava(i)
      const gridX = Math.floor(state.x[i] / GRID_CELLS),
        gridY = Math.floor(state.y[i] / GRID_CELLS)
      particleMap.add(gridX, gridY, i)
    }

    render(1)
  }

  document.body.append(sub(
    {
      style: {
        'font-size': '10px',
        position: 'fixed',
        bottom: '2px',
        left: '2px',
        'z-index': 200
      }

    },
    a({
      target: '_blank',
      href: 'https://github.com/narcolepticsnowman/lavalamp.app'
    }, 'Copyright Â© 2020 Robert Kempton')
  ))

  let lamp = lavalamp()
  document.body.append(bg(lamp))
  animateLava(lamp)

</script>
</body>
</html>
